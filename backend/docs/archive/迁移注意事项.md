# FastAPI 到 Django 迁移注意事项

## 概述

本文档记录了从 FastAPI + SQLAlchemy 迁移到 Django ORM 过程中需要注意的关键事项和最佳实践。

## 关键差异

### ORM 差异

#### 查询语法

**SQLAlchemy:**
```python
# 查询
users = session.query(User).filter(User.is_active == True).all()

# 关联查询
kb = session.query(KnowledgeBase).join(User).filter(User.username == 'test').first()
```

**Django ORM:**
```python
# 查询
users = Users.objects.filter(is_active=True)

# 关联查询
kb = KnowledgeBase.objects.select_related('uploader').filter(uploader__username='test').first()
```

#### 关系定义

**SQLAlchemy:**
```python
class KnowledgeBase(Base):
    uploader_id = Column(String(36), ForeignKey('users.id'))
    uploader = relationship('User', back_populates='knowledge_bases')
```

**Django ORM:**
```python
class KnowledgeBase(CoreModel):
    uploader = models.ForeignKey(
        to=Users,
        on_delete=models.PROTECT,
        related_name='uploaded_knowledge_bases'
    )
```

### 会话管理

**SQLAlchemy:**
- 需要显式管理会话（session）
- 需要手动提交事务
- 需要处理会话关闭

**Django ORM:**
- 自动管理数据库连接
- 自动提交事务（除非使用 `transaction.atomic()`）
- 不需要手动关闭连接

### 迁移系统

**SQLAlchemy (Alembic):**
```bash
alembic revision --autogenerate -m "message"
alembic upgrade head
```

**Django:**
```bash
python manage.py makemigrations
python manage.py migrate
```

## 数据类型映射

### UUID 字段

**SQLAlchemy:**
```python
id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
```

**Django:**
```python
id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
```

**注意：** Django 的 `UUIDField` 存储为原生 UUID 类型（如果数据库支持），而不是字符串。

### 时间戳字段

**SQLAlchemy:**
```python
created_at = Column(DateTime, default=datetime.utcnow)
updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
```

**Django:**
```python
create_datetime = models.DateTimeField(auto_now_add=True)
update_datetime = models.DateTimeField(auto_now=True)
```

**注意：** Django 使用 `auto_now_add` 和 `auto_now` 自动管理时间戳。

### JSON 字段

**SQLAlchemy:**
```python
data = Column(JSON)
```

**Django:**
```python
data = models.JSONField()
```

**注意：** Django 3.1+ 内置 JSONField，无需额外依赖。

## 外键关系

### on_delete 参数

Django 要求所有外键必须指定 `on_delete` 参数：

- `CASCADE`：级联删除，删除父对象时删除子对象
- `PROTECT`：保护删除，如果有子对象则不允许删除父对象
- `SET_NULL`：设置为 NULL（字段必须允许 NULL）
- `SET_DEFAULT`：设置为默认值
- `DO_NOTHING`：不做任何操作（可能导致数据库完整性错误）

**示例：**
```python
# 知识库文件应该随知识库一起删除
knowledge_base = models.ForeignKey(
    to=KnowledgeBase,
    on_delete=models.CASCADE,
    related_name='files'
)

# 用户不应该因为有上传的知识库而被删除
uploader = models.ForeignKey(
    to=Users,
    on_delete=models.PROTECT,
    related_name='uploaded_knowledge_bases'
)
```

### related_name

使用 `related_name` 提供清晰的反向关系访问：

```python
# 模型定义
class KnowledgeBase(CoreModel):
    uploader = models.ForeignKey(
        to=Users,
        on_delete=models.PROTECT,
        related_name='uploaded_knowledge_bases'
    )

# 使用
user = Users.objects.get(username='test')
user_kbs = user.uploaded_knowledge_bases.all()  # 清晰的访问方式
```

### 避免 related_name 冲突

当一个模型有多个外键指向同一个模型时，必须使用不同的 `related_name`：

```python
class Message(CoreModel):
    sender = models.ForeignKey(
        to=Users,
        on_delete=models.PROTECT,
        related_name='sent_messages'  # 发送的消息
    )
    recipient = models.ForeignKey(
        to=Users,
        on_delete=models.PROTECT,
        related_name='received_messages'  # 接收的消息
    )
```

## 唯一约束

### 单字段唯一

**SQLAlchemy:**
```python
email = Column(String(255), unique=True)
```

**Django:**
```python
email = models.EmailField(unique=True)
```

### 复合唯一约束

**SQLAlchemy:**
```python
__table_args__ = (
    UniqueConstraint('user_id', 'target_id', 'target_type'),
)
```

**Django:**
```python
class Meta:
    constraints = [
        models.UniqueConstraint(
            fields=['user', 'target_id', 'target_type'],
            name='unique_user_target_star'
        )
    ]
```

## 索引优化

### 单字段索引

**Django:**
```python
class Meta:
    indexes = [
        models.Index(fields=['is_public']),
        models.Index(fields=['create_datetime']),
    ]
```

### 复合索引

```python
class Meta:
    indexes = [
        models.Index(fields=['target_id', 'target_type']),
        models.Index(fields=['user', 'is_read']),
    ]
```

### 索引命名

Django 会自动生成索引名称，但也可以手动指定：

```python
models.Index(fields=['email'], name='idx_email')
```

## 查询优化

### 避免 N+1 查询

**问题：**
```python
# 每个知识库都会执行一次查询获取上传者信息
kbs = KnowledgeBase.objects.all()
for kb in kbs:
    print(kb.uploader.username)  # N+1 查询
```

**解决方案：**
```python
# 使用 select_related 一次性获取关联数据
kbs = KnowledgeBase.objects.select_related('uploader').all()
for kb in kbs:
    print(kb.uploader.username)  # 只执行一次查询
```

### 预取多对多关系

```python
# 预取评论和回复
comments = Comment.objects.prefetch_related('replies').filter(
    target_id=kb_id,
    is_deleted=False
)
```

### 只查询需要的字段

```python
# 只查询 id 和 name
kbs = KnowledgeBase.objects.only('id', 'name')

# 排除某些字段
kbs = KnowledgeBase.objects.defer('content', 'base_path')
```

## 事务管理

### 原子操作

```python
from django.db import transaction

@transaction.atomic
def create_knowledge_base_with_files(kb_data, files):
    """创建知识库和文件（原子操作）"""
    kb = KnowledgeBase.objects.create(**kb_data)
    
    for file_data in files:
        KnowledgeBaseFile.objects.create(
            knowledge_base=kb,
            **file_data
        )
    
    return kb
```

### 手动事务控制

```python
from django.db import transaction

def complex_operation():
    with transaction.atomic():
        # 创建保存点
        sid = transaction.savepoint()
        
        try:
            # 执行操作
            kb = KnowledgeBase.objects.create(...)
            # 更多操作...
            
            # 提交保存点
            transaction.savepoint_commit(sid)
        except Exception:
            # 回滚到保存点
            transaction.savepoint_rollback(sid)
            raise
```

## 数据验证

### 模型级验证

```python
from django.core.exceptions import ValidationError

class KnowledgeBase(CoreModel):
    def clean(self):
        """模型验证"""
        super().clean()
        
        # 验证版本号格式
        if self.version and not re.match(r'^\d+\.\d+$', self.version):
            raise ValidationError({
                'version': '版本号格式不正确，应为 x.y 格式'
            })
        
        # 验证公开内容必须通过审核
        if self.is_public and self.is_pending:
            raise ValidationError('公开内容必须先通过审核')
    
    def save(self, *args, **kwargs):
        """保存前验证"""
        self.full_clean()
        super().save(*args, **kwargs)
```

### 字段级验证

```python
from django.core.validators import MinValueValidator, MaxValueValidator

class KnowledgeBase(CoreModel):
    star_count = models.IntegerField(
        default=0,
        validators=[MinValueValidator(0)]
    )
```

## 信号处理

### 使用信号自动更新计数

```python
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver

@receiver(post_save, sender=StarRecord)
def increment_star_count(sender, instance, created, **kwargs):
    """收藏时增加收藏数"""
    if created:
        if instance.target_type == 'knowledge':
            kb = KnowledgeBase.objects.get(id=instance.target_id)
            kb.star_count += 1
            kb.save(update_fields=['star_count'])

@receiver(post_delete, sender=StarRecord)
def decrement_star_count(sender, instance, **kwargs):
    """取消收藏时减少收藏数"""
    if instance.target_type == 'knowledge':
        kb = KnowledgeBase.objects.get(id=instance.target_id)
        kb.star_count = max(0, kb.star_count - 1)
        kb.save(update_fields=['star_count'])
```

## 性能考虑

### 批量操作

**不推荐：**
```python
for data in large_dataset:
    DownloadRecord.objects.create(**data)  # 每次都执行一次 SQL
```

**推荐：**
```python
records = [DownloadRecord(**data) for data in large_dataset]
DownloadRecord.objects.bulk_create(records)  # 一次性插入
```

### 批量更新

```python
# 批量更新
KnowledgeBase.objects.filter(is_pending=True).update(is_pending=False)
```

### 使用 iterator() 处理大量数据

```python
# 避免一次性加载所有数据到内存
for kb in KnowledgeBase.objects.all().iterator():
    process(kb)
```

## 测试注意事项

### 使用测试数据库

Django 自动为测试创建独立的数据库，测试结束后自动清理。

### 测试事务

```python
from django.test import TestCase, TransactionTestCase

# 使用事务回滚（更快）
class MyTestCase(TestCase):
    def test_something(self):
        # 测试代码
        pass

# 不使用事务（用于测试事务相关功能）
class MyTransactionTestCase(TransactionTestCase):
    def test_transaction(self):
        # 测试代码
        pass
```

### 测试数据工厂

```python
from django.test import TestCase

class KnowledgeBaseTestCase(TestCase):
    def setUp(self):
        """创建测试数据"""
        self.user = Users.objects.create(
            username='testuser',
            email='test@example.com'
        )
        
        self.kb = KnowledgeBase.objects.create(
            name='测试知识库',
            description='描述',
            uploader=self.user
        )
    
    def test_create(self):
        """测试创建"""
        self.assertEqual(self.kb.name, '测试知识库')
```

## 部署注意事项

### 迁移执行顺序

1. 备份生产数据库
2. 在测试环境执行迁移
3. 验证迁移结果
4. 在生产环境执行迁移
5. 验证应用正常运行

### 零停机迁移

对于需要零停机的迁移：

1. **添加字段**：先添加字段（允许 NULL），然后填充数据，最后设置为 NOT NULL
2. **删除字段**：先在代码中停止使用，然后删除字段
3. **重命名字段**：使用数据库别名，避免直接重命名

### 回滚计划

每次迁移都应该有回滚计划：

```bash
# 查看当前迁移状态
python manage.py showmigrations

# 回滚到指定迁移
python manage.py migrate content 0001_initial

# 回滚所有迁移
python manage.py migrate content zero
```

## 常见问题

### 问题 1：迁移冲突

**症状：** 多个开发者同时创建迁移文件导致冲突

**解决方案：**
```bash
# 合并迁移
python manage.py makemigrations --merge
```

### 问题 2：循环依赖

**症状：** 模型之间存在循环外键引用

**解决方案：** 使用字符串引用
```python
parent = models.ForeignKey(
    to='self',  # 自引用
    on_delete=models.CASCADE
)

comment = models.ForeignKey(
    to='content.Comment',  # 跨应用引用
    on_delete=models.CASCADE
)
```

### 问题 3：迁移太慢

**症状：** 大表迁移执行时间过长

**解决方案：**
- 分批迁移数据
- 使用 `RunPython` 自定义迁移逻辑
- 考虑在低峰期执行

### 问题 4：外键约束错误

**症状：** 迁移时报外键约束错误

**解决方案：**
- 检查数据完整性
- 使用 `db_constraint=False` 禁用数据库级约束（仅在必要时）
- 清理孤立数据

## 最佳实践

1. **始终备份数据库**：在执行迁移前备份
2. **先在测试环境验证**：不要直接在生产环境执行未测试的迁移
3. **保持迁移文件简洁**：避免在迁移中包含复杂逻辑
4. **使用有意义的迁移名称**：便于理解迁移内容
5. **定期清理旧迁移**：使用 `squashmigrations` 合并旧迁移
6. **监控迁移性能**：记录迁移执行时间
7. **文档化特殊迁移**：为复杂迁移编写说明文档

## 相关资源

- [Django 迁移文档](https://docs.djangoproject.com/en/stable/topics/migrations/)
- [Django ORM 查询优化](https://docs.djangoproject.com/en/stable/topics/db/optimization/)
- [Django 测试文档](https://docs.djangoproject.com/en/stable/topics/testing/)
- [数据库迁移文档](./数据库迁移文档.md)

## 更新历史

| 日期 | 版本 | 说明 |
|------|------|------|
| 2026-02-25 | 1.0 | 初始版本 |
